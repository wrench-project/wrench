

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WRENCH 102 &mdash; WRENCH 2.8 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=8b628ae0" />

  
    <link rel="shortcut icon" href="_static/favicon.png"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=4348de45"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="WRENCH User C++ API" href="api_user.html" />
    <link rel="prev" title="WRENCH 101" href="wrench_101.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/wrench-dark-theme-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Quickstart</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing WRENCH</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="simulation_101.html">Simulation 101</a></li>
<li class="toctree-l1"><a class="reference internal" href="wrench_101.html">WRENCH 101</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">WRENCH 102</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-blueprint-for-an-execution-controller-implementation">Basic blueprint for an execution controller implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-finding-out-information-about-running-services">A) Finding out information about running services</a></li>
<li class="toctree-l2"><a class="reference internal" href="#b-interacting-with-services">B) Interacting with services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#managers">Managers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-storage-services">Interacting with storage services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-compute-services">Interacting with compute services</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-job-abstraction">The Job abstraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-function-abstraction">The Function abstraction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-details">More details</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-file-registry-services">Interacting with file registry services</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-network-proximity-services">Interacting with network proximity services</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#c-workflow-execution-events">C) Workflow execution events</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#finding-information-and-interacting-with-hardware-resources">Finding information and interacting with hardware resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="#logging">Logging</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api_user.html">WRENCH User C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_developer.html">WRENCH Developer C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_internal.html">WRENCH Internal C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="rest_api.html">WRENCH REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_api.html">WRENCH Python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">WRENCH</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">WRENCH 102</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/wrench_102.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="wrench-102">
<span id="wrench-102-header"></span><h1>WRENCH 102<a class="headerlink" href="#wrench-102" title="Link to this heading"></a></h1>
<p>In WRENCH’s terminology, and <em>execution controller</em> is software that
makes all decisions and takes all actions for executing some application
workflow using cyberinfrastructure services. It is thus a crucial
component in every WRENCH simulator. WRENCH does not provide any
execution controller implementation, but provides the means for
developing custom ones. This page is meant to provide high-level and
detailed information about implementing an execution controller in
WRENCH. Full API details are provided in the <a class="reference internal" href="api_developer.html#developer-api"><span class="std std-ref">Developer API
Reference</span></a>.</p>
<section id="basic-blueprint-for-an-execution-controller-implementation">
<span id="wrench-102-execution-controller-10000ft"></span><h2>Basic blueprint for an execution controller implementation<a class="headerlink" href="#basic-blueprint-for-an-execution-controller-implementation" title="Link to this heading"></a></h2>
<p>An execution controller implementation needs to use many WRENCH classes,
which are accessed by including a single header file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;wrench-dev.h&gt;</span>
</pre></div>
</div>
<p>An execution controller implementation must derive the
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionControllerE" title="wrench::ExecutionController"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController</span></code></a> class, which means that it must override
several the virtual <code class="docutils literal notranslate"><span class="pre">main()</span></code> member function. A typical such
implementation of this function goes through a simple loop as follows:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>//<span class="w"> </span>A<span class="o">)</span><span class="w"> </span>create/retrieve<span class="w"> </span>application<span class="w"> </span>workload<span class="w"> </span>to<span class="w"> </span>execute
//<span class="w"> </span>B<span class="o">)</span><span class="w"> </span>obtain<span class="w"> </span>information<span class="w"> </span>about<span class="w"> </span>running<span class="w"> </span>services
<span class="k">while</span><span class="w"> </span><span class="o">(</span>application<span class="w"> </span>workload<span class="w"> </span>execution<span class="w"> </span>has<span class="w"> </span>not<span class="w"> </span>completed/failed<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>//<span class="w"> </span>C<span class="o">)</span><span class="w"> </span>interact<span class="w"> </span>with<span class="w"> </span>services
<span class="w">  </span>//<span class="w"> </span>D<span class="o">)</span><span class="w"> </span><span class="nb">wait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>an<span class="w"> </span>event<span class="w"> </span>and<span class="w"> </span>react<span class="w"> </span>to<span class="w"> </span>it
<span class="o">}</span>
</pre></div>
</div>
<p>In the next three sections, we give details on how to implement the
above. To provide context, we make frequent references to the execution
controllers implemented as part of the example simulators in the
<code class="docutils literal notranslate"><span class="pre">examples/</span></code> directory. Afterwards are a few sections that highlight
features and functionality relevant to execution controller development.</p>
</section>
<section id="a-finding-out-information-about-running-services">
<span id="wrench-102-obtain-information"></span><h2>A) Finding out information about running services<a class="headerlink" href="#a-finding-out-information-about-running-services" title="Link to this heading"></a></h2>
<p>Services that the execution controller can use are typically passed to
its constructor. Most service classes provide member functions to get
information about the capabilities and properties of the services. For
instance, a <a class="reference internal" href="api_developer/classwrench_1_1_compute_service.html#_CPPv4N6wrench14ComputeServiceE" title="wrench::ComputeService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ComputeService</span></code></a> has a
<a class="reference internal" href="api_developer/classwrench_1_1_compute_service.html#_CPPv4N6wrench14ComputeService11getNumHostsEb" title="wrench::ComputeService::getNumHosts"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ComputeService::getNumHosts()</span></code></a> member function that returns
how many compute hosts the service has access to in total. A
<a class="reference internal" href="api_developer/classwrench_1_1_storage_service.html#_CPPv4N6wrench14StorageServiceE" title="wrench::StorageService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::StorageService</span></code></a> has a
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::StorageService::getFreeSpace()</span></code> member function to find out
how many bytes of free space are available on it. And so on…</p>
<p>To take a concrete example, consider the execution controller
implementation in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/batch-bag-of-tasks/TwoTasksAtATimeBatchWMS.cpp</span></code>.
This WMS finds out the compute speed of the cores of the compute nodes
available to a <a class="reference internal" href="api_developer/classwrench_1_1_batch_compute_service.html#_CPPv4N6wrench19BatchComputeServiceE" title="wrench::BatchComputeService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::BatchComputeService</span></code></a> as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">core_flop_rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">batch_service</span><span class="o">-&gt;</span><span class="n">getCoreFlopRate</span><span class="p">().</span><span class="n">begin</span><span class="p">())).</span><span class="n">second</span><span class="p">;</span>
</pre></div>
</div>
<p>Member function <a class="reference internal" href="api_developer/classwrench_1_1_compute_service.html#_CPPv4N6wrench14ComputeService15getCoreFlopRateEb" title="wrench::ComputeService::getCoreFlopRate"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ComputeService::getCoreFlopRate()</span></code></a> returns a
map of core compute speeds indexed by hostname (the map thus has one
element per compute node available to the service). Since the compute
nodes of a batch compute service are homogeneous, the above code simply
grabs the core speed value of the first element in the map.</p>
<p>It is important to note that these member functions actually involve
communication with the service, and thus incur overhead that is part of
the simulation (as if, in the real-world, you would contact a running
service with a request for information over the network). This is why
the line of code above, in that example execution controller, is
executed once and the core compute speed is stored in the
<code class="docutils literal notranslate"><span class="pre">core_flop_rate</span></code> variable to be re-used by the execution controller
repeatedly throughout its execution.</p>
</section>
<section id="b-interacting-with-services">
<span id="wrench-102-controller-services"></span><h2>B) Interacting with services<a class="headerlink" href="#b-interacting-with-services" title="Link to this heading"></a></h2>
<p>An execution controller can have many and complex interactions with
services, especially with compute and storage services. In this section,
we describe how WRENCH makes these interactions relatively easy,
providing examples for each kind of interaction for each kind of
service.</p>
<section id="managers">
<span id="wrench-102-controller-services-managers"></span><h3>Managers<a class="headerlink" href="#managers" title="Link to this heading"></a></h3>
<p>As expected, each service type provides its own API. For instance, a
network proximity service provides member functions to query the
service’s host distance databases. The <a class="reference internal" href="api_developer.html#developer-api"><span class="std std-ref">Developer API
Reference</span></a> provides all necessary
documentation, which also explains which member functions are
synchronous and which are asynchronous (in which case some
<a class="reference internal" href="#wrench-102-controller-events"><span class="std std-ref">event</span></a> will occur in the
future). <strong>However, the WRENCH developer will find that many member
functions that one would expect are nowhere to be found. For instance,
a bare-metal compute service does not have (public) member functions for
submitting jobs for execution!</strong></p>
<p>The rationale for the above is that many member functions need to be
asynchronous so that the execution controller can use services
concurrently. For instance, an execution controller could submit a job
to two distinct compute services asynchronously, and then wait for the
service which completes its job first and cancel the job on the other
service. Exposing this asynchronicity to the execution controller would
require that the WRENCH developer use data structures to perform the
necessary bookkeeping of ongoing service interactions, and process
incoming control messages from the services on the (simulated) network
or alternately register many callbacks. Instead, WRENCH provides
<strong>managers</strong>. One can think of managers as separate threads that handle
all asynchronous interactions with services, and which have been
implemented for your convenience to make interacting with services easy.</p>
<p>There are three managers: a <strong>job manager</strong>
(class <a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManagerE" title="wrench::JobManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager</span></code></a>), a <strong>function manager</strong> (class <a class="reference internal" href="api_developer/classwrench_1_1_function_manager.html#_CPPv4N6wrench15FunctionManagerE" title="wrench::FunctionManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FunctionManager</span></code></a>),
and a <strong>data movement manager</strong> (class
<a class="reference internal" href="api_developer/classwrench_1_1_data_movement_manager.html#_CPPv4N6wrench19DataMovementManagerE" title="wrench::DataMovementManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::DataMovementManager</span></code></a>). The base
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionControllerE" title="wrench::ExecutionController"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController</span></code></a> class provides member functions for
instantiating and starting these managers:
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController16createJobManagerEv" title="wrench::ExecutionController::createJobManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::createJobManager()</span></code></a>,
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController21createFunctionManagerEv" title="wrench::ExecutionController::createFunctionManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::createFunctionManager()</span></code></a>, and
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController25createDataMovementManagerEv" title="wrench::ExecutionController::createDataMovementManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::createDataMovementManager()</span></code></a>.</p>
<p>Creating managers typically is the first thing an
execution controller does. For instance, the execution controller in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/bare-metal-data-movement/DataMovementWMS.cpp</span></code>
starts by doing:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">job_manager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">createJobManager</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">data_movement_manager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">createDataMovementManager</span><span class="p">();</span>
</pre></div>
</div>
<p>Each manager has its own documented API, and is discussed further in
sections below.</p>
</section>
<section id="interacting-with-storage-services">
<span id="wrench-102-controller-services-storage"></span><h3>Interacting with storage services<a class="headerlink" href="#interacting-with-storage-services" title="Link to this heading"></a></h3>
<p>Typical interactions between an execution controller and a storage
service include locating, reading, writing, and copying files. Different storage
service implementations may or not implement some of of these operations. Some operations
can be done directly, while other require using a data movement manager (see above).</p>
<p>Click on the following links to see concrete examples
of interactions with the currently available storage service type:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="wrench_102/simplestorage.html#guide-102-simplestorage"><span class="std std-ref">Simple storage service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/xrootd.html#guide-102-xrootd"><span class="std std-ref">XRootD storage service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/storageserviceproxy.html#guide-102-storageserviceproxy"><span class="std std-ref">Storage service proxy</span></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="interacting-with-compute-services">
<span id="wrench-102-controller-services-compute"></span><h3>Interacting with compute services<a class="headerlink" href="#interacting-with-compute-services" title="Link to this heading"></a></h3>
<section id="the-job-abstraction">
<span id="wrench-102-controller-services-compute-job"></span><h4>The Job abstraction<a class="headerlink" href="#the-job-abstraction" title="Link to this heading"></a></h4>
<p>Some compute services support the execution of “jobs”, and
a common activity of an execution controller is to execute jobs
on these compute services. An execution controller must use a job manager (see previous section)
to create and submit jobs for execution to compute services. The
job abstraction is powerful and greatly simplifies the task of an
execution controller while affording flexibility.</p>
<p><strong>There are three kinds of jobs in WRENCH</strong>: <a class="reference internal" href="api_developer/classwrench_1_1_compound_job.html#_CPPv4N6wrench11CompoundJobE" title="wrench::CompoundJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::CompoundJob</span></code></a>,
<a class="reference internal" href="api_developer/classwrench_1_1_standard_job.html#_CPPv4N6wrench11StandardJobE" title="wrench::StandardJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::StandardJob</span></code></a>, and <a class="reference internal" href="api_developer/classwrench_1_1_pilot_job.html#_CPPv4N6wrench8PilotJobE" title="wrench::PilotJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::PilotJob</span></code></a>. Different
compute services support different kinds of jobs.</p>
<p>A <strong>Compound Job</strong> is simply set of actions to be performed, with
possible control dependencies between actions. It is the most generic,
flexible, and expressive kind of job. See the API documentation for the
<a class="reference internal" href="api_developer/classwrench_1_1_compound_job.html#_CPPv4N6wrench11CompoundJobE" title="wrench::CompoundJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::CompoundJob</span></code></a> class and the examples in the
<code class="docutils literal notranslate"><span class="pre">examples/action_api</span></code> directory. The other types of jobs below are
actually implemented internally as compound jobs. The Compound Job
abstraction is the most recent addition to the WRENCH API, and vastly
expands the list of possible things that an execution controller can do.
But because it is more recent, the reader will find that there are more
examples in these documents and in the <code class="docutils literal notranslate"><span class="pre">examples</span></code> directory that use
standard jobs (described below). But all these examples could be easily
rewritten using the more generic compound job abstraction.</p>
<p>A <strong>Standard Job</strong> is a specific kind of job designed for <strong>workflow</strong>
applications. In its most complete form, a standard job specifies:</p>
<ul class="simple">
<li><p>A set (in fact a vector) of <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;wrench::WorkflowTask&gt;</span></code> to
execute, so that each task without all its predecessors in the set is
ready;</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">std::map</span></code> of
<code class="docutils literal notranslate"><span class="pre">&lt;std::shared_ptr&lt;wrench::DataFile&gt;&gt;,</span> <span class="pre">std::shared_ptr&lt;wrench::StorageService&gt;&gt;</span></code>
pairs that specifies from which storage services particular input
files should be read and to which storage services output files
should be written;</p></li>
<li><p>A set of file copy operations to be performed before executing the
tasks;</p></li>
<li><p>A set of file copy operations to be performed after executing the
tasks; and</p></li>
<li><p>A set of file deletion operations to be performed after executing the
tasks and file copy operations.</p></li>
</ul>
<p>Any of the above can actually be empty, and in the extreme a standard
job can do nothing.</p>
<p>A <strong>Pilot Job</strong> (sometimes called a “placeholder job” in the literature)
is a concept that is mostly relevant for batch scheduling. In a
nutshell, it is a job that allows late binding of tasks to resources. It
is submitted to a compute service (provided that service supports pilot
jobs), and when it starts it just looks to the execution controller like
a short-lived <a class="reference internal" href="api_developer/classwrench_1_1_bare_metal_compute_service.html#_CPPv4N6wrench23BareMetalComputeServiceE" title="wrench::BareMetalComputeService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::BareMetalComputeService</span></code></a> to which compound
and/or standard jobs can be submitted.</p>
<p>All jobs are created via the job manager, which provides
<a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManager17createCompoundJobENSt6stringE" title="wrench::JobManager::createCompoundJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager::createCompoundJob()</span></code></a>,
<a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManager17createStandardJobERKNSt10shared_ptrI12WorkflowTaskEE" title="wrench::JobManager::createStandardJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager::createStandardJob()</span></code></a>, and
<a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManager14createPilotJobEv" title="wrench::JobManager::createPilotJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager::createPilotJob()</span></code></a> member functions (the job
manager is thus a job factory).</p>
<p>In addition to member functions for job creation, the job manager also
provides the following:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManager9submitJobERKNSt10shared_ptrI11CompoundJobEERKNSt10shared_ptrI14ComputeServiceEENSt3mapINSt6stringENSt6stringEEE" title="wrench::JobManager::submitJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager::submitJob()</span></code></a>: asynchronous submission of a job
to a compute service.</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_job_manager.html#_CPPv4N6wrench10JobManager12terminateJobERKNSt10shared_ptrI11CompoundJobEE" title="wrench::JobManager::terminateJob"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::JobManager::terminateJob()</span></code></a>: synchronous termination of a
previously submitted job.</p></li>
</ul>
</section>
<section id="the-function-abstraction">
<h4>The Function abstraction<a class="headerlink" href="#the-function-abstraction" title="Link to this heading"></a></h4>
<p>Another way for an execution controller to use compute service is not via a job abstraction, but via
a function abstraction. This abstraction is only supported by serverless compute services (<a class="reference internal" href="api_developer/classwrench_1_1_serverless_compute_service.html#_CPPv4N6wrench24ServerlessComputeServiceE" title="wrench::ServerlessComputeService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ServerlessComputeService</span></code></a>).
Functions are created, registered, invoked, and monitored by a function manager (<a class="reference internal" href="api_developer/classwrench_1_1_function_manager.html#_CPPv4N6wrench15FunctionManagerE" title="wrench::FunctionManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FunctionManager</span></code></a>).  A function
is defined by arbitrary code (i.e., any lambda function that uses the WRENCH API), an image file that is stored on at least one storage
service, limits on a function invocation’s resource usage, and a timeout.  Once registered, the function can be invoked any number of times,
and the controller can check on the status of an invocation and wait for one or more invocations to complete (successfully or not).</p>
</section>
<section id="more-details">
<h4>More details<a class="headerlink" href="#more-details" title="Link to this heading"></a></h4>
<p>Click on the following links to see detailed descriptions and examples
of how jobs are submitted to each compute service type:</p>
<ul class="simple">
<li><p><a class="reference internal" href="wrench_102/baremetal.html#guide-102-baremetal"><span class="std std-ref">Bare-metal compute service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/batch.html#guide-102-batch"><span class="std std-ref">Batch compute service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/cloud.html#guide-102-cloud"><span class="std std-ref">Cloud compute service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/virtualizedcluster.html#guide-102-virtualizedcluster"><span class="std std-ref">Virtualized cluster compute service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/htcondor.html#guide-102-htcondor"><span class="std std-ref">HTCondor compute service</span></a></p></li>
<li><p><a class="reference internal" href="wrench_102/serverless.html#guide-102-serverless"><span class="std std-ref">Serverless compute service</span></a></p></li>
</ul>
</section>
</section>
<section id="interacting-with-file-registry-services">
<span id="wrench-102-controller-services-registry"></span><h3>Interacting with file registry services<a class="headerlink" href="#interacting-with-file-registry-services" title="Link to this heading"></a></h3>
<p>Interaction with a file registry service is straightforward and done by
directly calling member functions of the <a class="reference internal" href="api_developer/classwrench_1_1_file_registry_service.html#_CPPv4N6wrench19FileRegistryServiceE" title="wrench::FileRegistryService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FileRegistryService</span></code></a>
class. Note that often file registry service entries are managed
automatically, e.g., via calls to <a class="reference internal" href="api_developer/classwrench_1_1_data_movement_manager.html#_CPPv4N6wrench19DataMovementManagerE" title="wrench::DataMovementManager"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::DataMovementManager</span></code></a> and
<a class="reference internal" href="api_developer/classwrench_1_1_storage_service.html#_CPPv4N6wrench14StorageServiceE" title="wrench::StorageService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::StorageService</span></code></a> member functions. So often an execution
controller does not need to interact with the file registry service.</p>
<p>Adding/removing an entry to a file registry service is done as follows:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>std::shared_ptr&lt;wrench::FileRegistryService&gt;<span class="w"> </span>file_registry<span class="p">;</span>
std::shared_ptr&lt;wrench::DataFile&gt;<span class="w"> </span>some_file<span class="p">;</span>
std::shared_ptr&lt;wrench::StorageService&gt;<span class="w"> </span>some_storage_service<span class="p">;</span>

<span class="o">[</span>...<span class="o">]</span>

file_registry-&gt;addEntry<span class="o">(</span>wrench::FileLocation::LOCATION<span class="o">(</span>some_storage_service,<span class="w"> </span>some_file<span class="o">))</span><span class="p">;</span>
file_registry-&gt;removeEntry<span class="o">(</span>wrench::FileLocation::LOCATION<span class="o">(</span>some_storage_service,<span class="w"> </span>some_file<span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="api_developer/classwrench_1_1_file_location.html#_CPPv4N6wrench12FileLocationE" title="wrench::FileLocation"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FileLocation</span></code></a> class is a convenient abstraction for a
file that is available at some storage service (with optionally a directory
path at that service).</p>
<p>Retrieving all entries for a given file is done as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">FileRegistryService</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file_registry</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">DataFile</span><span class="o">&gt;</span><span class="w"> </span><span class="n">some_file</span><span class="p">;</span>

<span class="p">[...]</span>

<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">FileLocation</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">entries</span><span class="p">;</span>
<span class="n">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file_registry</span><span class="o">-&gt;</span><span class="n">lookupEntry</span><span class="p">(</span><span class="n">some_file</span><span class="p">);</span>
</pre></div>
</div>
<p>If a network proximity service is running, it is possible to retrieve
entries for a file sorted by non-decreasing proximity from some
reference host. Returned entries are stored in a (sorted) <code class="docutils literal notranslate"><span class="pre">std::map</span></code>
where the keys are network distances to the reference host. For
instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">FileRegistryService</span><span class="o">&gt;</span><span class="w"> </span><span class="n">file_registry</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">DataFile</span><span class="o">&gt;</span><span class="w"> </span><span class="n">some_file</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">NetworkProximityService</span><span class="o">&gt;</span><span class="w"> </span><span class="n">np_service</span><span class="p">;</span>

<span class="p">[...]</span>

<span class="k">auto</span><span class="w"> </span><span class="n">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fr_service</span><span class="o">-&gt;</span><span class="n">lookupEntry</span><span class="p">(</span><span class="n">some_file</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ReferenceHost&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">np_service</span><span class="p">);</span>
</pre></div>
</div>
<p>See the documentation of <a class="reference internal" href="api_developer/classwrench_1_1_file_registry_service.html#_CPPv4N6wrench19FileRegistryServiceE" title="wrench::FileRegistryService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FileRegistryService</span></code></a>
for more API member functions.</p>
</section>
<section id="interacting-with-network-proximity-services">
<span id="wrench-102-controller-services-network"></span><h3>Interacting with network proximity services<a class="headerlink" href="#interacting-with-network-proximity-services" title="Link to this heading"></a></h3>
<p>Querying a network proximity service is straightforward. For instance,
to obtain a measure of the network distance between hosts “Host1” and
“Host2”, one simply does:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">NetworkProximityService</span><span class="o">&gt;</span><span class="w"> </span><span class="n">np_service</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np_service</span><span class="o">-&gt;</span><span class="n">getHostPairDistance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&quot;Host1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Host2&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This distance corresponds to half the round-trip-time, in seconds,
between the two hosts. The second value of the pair is the timestamp of
the oldest measurement uses to compute the proximity value. If the service
is configured to use the Vivaldi coordinate-based system, as in our example above,
this distance is actually derived from network coordinates, as computed
by the Vivaldi algorithm. In this case, one can actually ask for these
coordinates for any given host:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">coords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np_service</span><span class="o">-&gt;</span><span class="n">getHostCoordinate</span><span class="p">(</span><span class="s">&quot;Host1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>See the documentation of <a class="reference internal" href="api_developer/classwrench_1_1_network_proximity_service.html#_CPPv4N6wrench23NetworkProximityServiceE" title="wrench::NetworkProximityService"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::NetworkProximityService</span></code></a>
for more API member functions.</p>
</section>
</section>
<section id="c-workflow-execution-events">
<span id="wrench-102-controller-events"></span><h2>C) Workflow execution events<a class="headerlink" href="#c-workflow-execution-events" title="Link to this heading"></a></h2>
<p>Because the execution controller performs asynchronous operations, it
needs to wait for and re-act to events. This is done by calling the
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController26waitForAndProcessNextEventEv" title="wrench::ExecutionController::waitForAndProcessNextEvent"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::waitForAndProcessNextEvent()</span></code></a> member
function implemented by the base <code class="docutils literal notranslate"><span class="pre">wrench::ExecutionController</span></code> class.
A call to this member function blocks until some event occurs and then
calls a callback member function. The possible event classes all derive
from the <a class="reference internal" href="api_developer/classwrench_1_1_execution_event.html#_CPPv4N6wrench14ExecutionEventE" title="wrench::ExecutionEvent"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionEvent</span></code></a> class, and an execution controller
can override the callback member function for each possible event (the
default member function does nothing but print some log message). These
overridable callback member functions are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController33processEventCompoundJobCompletionERKNSt10shared_ptrI25CompoundJobCompletedEventEE" title="wrench::ExecutionController::processEventCompoundJobCompletion"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventCompoundJobCompletion()</span></code></a>:
react to a compound job completion</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController30processEventCompoundJobFailureERKNSt10shared_ptrI22CompoundJobFailedEventEE" title="wrench::ExecutionController::processEventCompoundJobFailure"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventCompoundJobFailure()</span></code></a>:
react to a compound job failure</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController33processEventStandardJobCompletionERKNSt10shared_ptrI25StandardJobCompletedEventEE" title="wrench::ExecutionController::processEventStandardJobCompletion"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventStandardJobCompletion()</span></code></a>:
react to a standard job completion</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController30processEventStandardJobFailureERKNSt10shared_ptrI22StandardJobFailedEventEE" title="wrench::ExecutionController::processEventStandardJobFailure"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventStandardJobFailure()</span></code></a>:
react to a standard job failure</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController25processEventPilotJobStartERKNSt10shared_ptrI20PilotJobStartedEventEE" title="wrench::ExecutionController::processEventPilotJobStart"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventPilotJobStart()</span></code></a>: react
to a pilot job beginning execution</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController30processEventPilotJobExpirationERKNSt10shared_ptrI20PilotJobExpiredEventEE" title="wrench::ExecutionController::processEventPilotJobExpiration"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventPilotJobExpiration()</span></code></a>:
react to a pilot job expiration</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController30processEventFileCopyCompletionERKNSt10shared_ptrI22FileCopyCompletedEventEE" title="wrench::ExecutionController::processEventFileCopyCompletion"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventFileCopyCompletion()</span></code></a>:
react to a file copy completion</p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionController27processEventFileCopyFailureERKNSt10shared_ptrI19FileCopyFailedEventEE" title="wrench::ExecutionController::processEventFileCopyFailure"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController::processEventFileCopyFailure()</span></code></a>: react
to a file copy failure</p></li>
</ul>
<p>Each member function above takes in an event object as parameter. In the
case of failure, the event includes a <a class="reference internal" href="api_developer/classwrench_1_1_failure_cause.html#_CPPv4N6wrench12FailureCauseE" title="wrench::FailureCause"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FailureCause</span></code></a> object,
which can be accessed to analyze (or just display) the root cause of the
failure.</p>
<p>Consider the execution controller in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/bare-metal-bag-of-tasks/TwoTasksAtATimeWMS.cpp</span></code>.
At each each iteration of its main loop it does:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Submit some standard job to some compute  service</span>
<span class="n">job_manager</span><span class="o">-&gt;</span><span class="n">submitJob</span><span class="p">(...);</span>

<span class="c1">// Wait for and process next event</span>
<span class="k">this</span><span class="o">-&gt;</span><span class="n">waitForAndProcessNextEvent</span><span class="p">();</span>
</pre></div>
</div>
<p>In this simple example, only one of two events could occur at this
point: a standard job completion or a standard job failure. As a result,
this execution controller overrides the two corresponding member
functions as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">TwoTasksAtATimeWMS::processEventStandardJobCompletion</span><span class="p">(</span>
<span class="w">               </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">StandardJobCompletedEvent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Retrieve the job that this event is for</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">standard_job</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Print some message for each task in the job</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">task</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">job</span><span class="o">-&gt;</span><span class="n">getTasks</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Notified that a standard job has completed task &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">TwoTasksAtATimeWMS::processEventStandardJobFailure</span><span class="p">(</span>
<span class="w">               </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">StandardJobFailedEvent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Retrieve the job that this event is for</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">standard_job</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Notified that a standard job has failed (failure cause: &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">failure_cause</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Print some message for each task in the job if it has failed</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;As a result, the following tasks have failed:&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="n">task</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">job</span><span class="o">-&gt;</span><span class="n">getTasks</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">getState</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">WorkflowTask</span><span class="o">::</span><span class="n">COMPLETE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w">  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  - &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">task</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You may note some difference between the above code and that in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/bare-metal-bag-of-tasks/TwoTasksAtATimeWMS.cpp</span></code>.
This is for clarity purposes, and especially because we have not yet
explained how WRENCH does message logging. See <a class="reference internal" href="#wrench-102-controller-logging"><span class="std std-ref">an upcoming section
about logging</span></a>.</p>
<p>While the above callbacks are convenient, sometimes it is desirable to
do things more manually. That is, wait for an event and then process it
in the code of the main loop of the execution controller rather than in
a callback member function. This is done by calling the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::waitForNextEvent()</span></code> member function. For instance, the
execution controller in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/bare-metal-data-movement/DataMovementWMS.cpp</span></code>
does it as:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initiate an asynchronous file copy</span>
<span class="n">data_movement_manager</span><span class="o">-&gt;</span><span class="n">initiateAsynchronousFileCopy</span><span class="p">(...);</span>

<span class="c1">// Wait for an event</span>
<span class="k">auto</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">waitForNextEvent</span><span class="p">();</span>

<span class="c1">//Process the event</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">file_copy_completion_event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">dynamic_pointer_cast</span><span class="o">&lt;</span><span class="n">wrench</span><span class="o">::</span><span class="n">FileCopyCompletedEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">event</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Notified of a file copy completion for file &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">file_copy_completion_event</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">getID</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;as expected&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Unexpected event (&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">);}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="exceptions">
<span id="wrench-102-controller-exceptions"></span><h2>Exceptions<a class="headerlink" href="#exceptions" title="Link to this heading"></a></h2>
<p>Most member functions in the WRENCH Developer API throw exceptions. In
fact, most of the code fragments above should be in try-catch clauses,
catching these exceptions.</p>
<p>Some exceptions correspond to failures during the simulated workflow
executions (i.e., errors that would occur in a real-world execution and
are thus part of the simulation). Each such exception contains a
<a class="reference internal" href="api_developer/classwrench_1_1_failure_cause.html#_CPPv4N6wrench12FailureCauseE" title="wrench::FailureCause"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::FailureCause</span></code></a> object, which can be accessed to understand the
root cause of the execution failure. Other exceptions (e.g.,
<code class="docutils literal notranslate"><span class="pre">std::invalid_arguments</span></code>, <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code>) are thrown as well,
which are used for detecting misuses of the WRENCH API or internal
WRENCH errors.</p>
</section>
<section id="finding-information-and-interacting-with-hardware-resources">
<span id="wrench-102-controller-hardware"></span><h2>Finding information and interacting with hardware resources<a class="headerlink" href="#finding-information-and-interacting-with-hardware-resources" title="Link to this heading"></a></h2>
<p>The <a class="reference internal" href="api_developer/classwrench_1_1_simulation.html#_CPPv4N6wrench10SimulationE" title="wrench::Simulation"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::Simulation</span></code></a> class provides many member functions to
discover information about the (simulated) hardware platform and
interact with it. It also provides other useful information about the
simulation itself, such as the current simulation date. Some of these
member functions are static, but others are not. The
<a class="reference internal" href="api_developer/classwrench_1_1_execution_controller.html#_CPPv4N6wrench19ExecutionControllerE" title="wrench::ExecutionController"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::ExecutionController</span></code></a> class includes a <code class="docutils literal notranslate"><span class="pre">simulation</span></code> object.
Thus, the execution controller can call member functions on the
<code class="docutils literal notranslate"><span class="pre">this-&gt;simulation</span></code> object. For instance, this fragment of code shows
how an execution controller can figure out the current simulated date
and then check that a host exists (given a hostname) and, if so, set its
<code class="docutils literal notranslate"><span class="pre">pstate</span></code> (power state) to the highest possible setting.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wrench</span><span class="o">::</span><span class="n">Simulation</span><span class="o">::</span><span class="n">getCurrentSimulatedDate</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wrench</span><span class="o">::</span><span class="n">Simulation</span><span class="o">::</span><span class="n">doesHostExist</span><span class="p">(</span><span class="s">&quot;SomeHost&quot;</span><span class="p">))</span><span class="w">  </span><span class="p">{</span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">simulation</span><span class="o">-&gt;</span><span class="n">setPstate</span><span class="p">(</span><span class="s">&quot;SomeHost&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wrench</span><span class="o">::</span><span class="n">Simulation</span><span class="o">::</span><span class="n">getNumberofPstates</span><span class="p">(</span><span class="s">&quot;SomeHost&quot;</span><span class="p">)</span><span class="mi">-1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>See the documentation of the <a class="reference internal" href="api_developer/classwrench_1_1_simulation.html#_CPPv4N6wrench10SimulationE" title="wrench::Simulation"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::Simulation</span></code></a> class for all
details. Specifically regarding host pstates, see the example execution
controller in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/cloud-bag-of-tasks-energy/TwoTasksAtATimeCloudWMS.cpp</span></code>,
which interacts with host pstates (and the
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/cloud-bag-of-tasks-energy/four_hosts_energy.xml</span></code>
platform description file which defines pstates).</p>
</section>
<section id="logging">
<span id="wrench-102-controller-logging"></span><h2>Logging<a class="headerlink" href="#logging" title="Link to this heading"></a></h2>
<p>It is typically desirable for the execution controller to print log
output to the terminal. This is easily accomplished using the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::WRENCH_INFO()</span></code>, <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::WRENCH_DEBUG()</span></code>, and
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::WRENCH_WARN()</span></code> macros, which are used just like C’s
<code class="docutils literal notranslate"><span class="pre">printf()</span></code>. Each of these macros corresponds to a different logging
level in SimGrid. See the <span class="xref std std-ref">SimGrid logging
documentation</span> for all
details.</p>
<p>Furthermore, one can change the color of the log messages with the
<a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput26setThisProcessLoggingColorE5Color" title="wrench::TerminalOutput::setThisProcessLoggingColor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::setThisProcessLoggingColor()</span></code></a> member
function, which takes as parameter a color specification:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color11COLOR_BLACKE" title="wrench::TerminalOutput::COLOR_BLACK"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_BLACK</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color9COLOR_REDE" title="wrench::TerminalOutput::COLOR_RED"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_RED</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color11COLOR_GREENE" title="wrench::TerminalOutput::COLOR_GREEN"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_GREEN</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color12COLOR_YELLOWE" title="wrench::TerminalOutput::COLOR_YELLOW"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_YELLOW</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color10COLOR_BLUEE" title="wrench::TerminalOutput::COLOR_BLUE"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_BLUE</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color13COLOR_MAGENTAE" title="wrench::TerminalOutput::COLOR_MAGENTA"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_MAGENTA</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color10COLOR_CYANE" title="wrench::TerminalOutput::COLOR_CYAN"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_CYAN</span></code></a></p></li>
<li><p><a class="reference internal" href="api_developer/classwrench_1_1_terminal_output.html#_CPPv4N6wrench14TerminalOutput5Color11COLOR_WHITEE" title="wrench::TerminalOutput::COLOR_WHITE"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::TerminalOutput::COLOR_WHITE</span></code></a></p></li>
</ul>
<p>When inspecting the code of the execution controllers in the example
simulators you will find many examples of calls to
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrench::WRENCH_INFO()</span></code>. The logging is per <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file, each of
which corresponds to a declared logging category. For instance, in
<code class="docutils literal notranslate"><span class="pre">examples/workflow_api/basic-examples/batch-bag-of-tasks/TwoTasksAtATimeBatchWMS.cpp</span></code>,
you will find the typical pattern:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define a log category name for this file</span>
<span class="n">WRENCH_LOG_CATEGORY</span><span class="p">(</span><span class="n">custom_wms</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Log category for TwoTasksAtATimeBatchWMS&quot;</span><span class="p">);</span>

<span class="p">[...]</span>

<span class="kt">int</span><span class="w"> </span><span class="n">TwoTasksAtATimeBatchWMS</span><span class="o">::</span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Set the logging color to green</span>
<span class="w">  </span><span class="n">TerminalOutput</span><span class="o">::</span><span class="n">setThisProcessLoggingColor</span><span class="p">(</span><span class="n">TerminalOutput</span><span class="o">::</span><span class="n">COLOR_GREEN</span><span class="p">);</span>

<span class="w">  </span><span class="p">[...]</span>

<span class="w">  </span><span class="c1">// Print an info-level message, using printf-like format</span>
<span class="w">  </span><span class="n">WRENCH_INFO</span><span class="p">(</span><span class="s">&quot;Submitting the job, asking for %s %s-core nodes for %s seconds&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="n">service_specific_arguments</span><span class="p">[</span><span class="s">&quot;-N&quot;</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">              </span><span class="n">service_specific_arguments</span><span class="p">[</span><span class="s">&quot;-c&quot;</span><span class="p">].</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">              </span><span class="n">service_specific_arguments</span><span class="p">[</span><span class="s">&quot;-t&quot;</span><span class="p">].</span><span class="n">c_str</span><span class="p">());</span>

<span class="w">  </span><span class="p">[...]</span>

<span class="w">  </span><span class="c1">// Print a last info-level message</span>
<span class="w">  </span><span class="n">WRENCH_INFO</span><span class="p">(</span><span class="s">&quot;Workflow execution complete&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The name of the logging category, in this case <code class="docutils literal notranslate"><span class="pre">custom_wms</span></code>, can then
be passed to the <code class="docutils literal notranslate"><span class="pre">--log</span></code> command-line argument. For instance, invoking
the simulator with additional argument
<code class="docutils literal notranslate"><span class="pre">--log=custom_wms.threshold=info</span></code> will make it so that only those
<code class="docutils literal notranslate"><span class="pre">WRENCH_INFO</span></code> statements in <code class="docutils literal notranslate"><span class="pre">TwoTasksAtATimeBatchWMS.cpp</span></code> will be
printed (in green!).</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="wrench_101.html" class="btn btn-neutral float-left" title="WRENCH 101" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api_user.html" class="btn btn-neutral float-right" title="WRENCH User C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2022, WRENCH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>